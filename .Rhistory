y=c(1,1,1,1)
hamming.distance(x,y)
#Come implementare la distanza di Hamming con R?
#Esiste una funzione
hamming.distance<-function (x, y)
{
if(length(x)!=length(y))
{
stop("x and y must have the same length")
}
x=paste(x,collapse="")
y=paste(y,collapse="")
z <- apply(do.call(rbind, strsplit(c(x, y), "")), 2,
function(x){length(unique(x[!x %in% "_"])) == 1})
z=sum(z)
return(z)
}
x=c(3,4,0,1)
y=c(1,1,1,1)
hamming.distance(x,y)
#Come implementare la distanza di Hamming con R?
#Esiste una funzione Hamming Distance ma funziona in modo booleano
#Quindi se due elementi sono zero (o entrambi diversi da 0) mi da true
#Altrimenti se uno è 0 e l'altro no mi da false
#Io voglio implementare una funzione che confronti i singoli elementi
hamming.distance<-function (x, y)
{
if(length(x)!=length(y))
{
stop("x and y must have the same length")
}
x=paste(x,collapse="")
y=paste(y,collapse="")
z <- apply(do.call(rbind, strsplit(c(x, y), "")), 2,
function(x){length(unique(x[!x %in% "_"])) == 1})
z=sum(z)
return(z)
}
x=c(3,4,0,1)
y=c(1,1,1,1)
hamming.distance(x,y)
x="Ciao"
y="Ciao"
hamming.distance(x,y)
x="Ciao"
y="Ciad"
hamming.distance(x,y)
hamming.distance(x,y)
x=c(3,4,0,1)
y=c(1,1,1,1)
hamming.distance(x,y)
#Come implementare la distanza di Hamming con R?
#Esiste una funzione Hamming Distance ma funziona in modo booleano
#Quindi se due elementi sono zero (o entrambi diversi da 0) mi da true
#Altrimenti se uno è 0 e l'altro no mi da false
#Io voglio implementare una funzione che confronti i singoli elementi
hamming.distance<-function (x, y)
{
if(length(x)!=length(y))
{
stop("x and y must have the same length")
}
x=paste(x,collapse="")
y=paste(y,collapse="")
z <- apply(do.call(rbind, strsplit(c(x, y), "")), 2,
function(x){length(unique(x[!x %in% "_"])) == 1})
z=length(x)-sum(z)
return(z)
}
x=c(3,4,0,1)
y=c(1,1,1,1)
hamming.distance(x,y)
x=c(3,4,0,1)
y=c(1,1,1,1)
hamming.distance(x,y)
#Come implementare la distanza di Hamming con R?
#Esiste una funzione Hamming Distance ma funziona in modo booleano
#Quindi se due elementi sono zero (o entrambi diversi da 0) mi da true
#Altrimenti se uno è 0 e l'altro no mi da false
#Io voglio implementare una funzione che confronti i singoli elementi
hamming.distance<-function (x, y)
{
if(length(x)!=length(y))
{
stop("x and y must have the same length")
}
l=length(x)
x=paste(x,collapse="")
y=paste(y,collapse="")
z <- apply(do.call(rbind, strsplit(c(x, y), "")), 2,
function(x){length(unique(x[!x %in% "_"])) == 1})
z=l-sum(z)
return(z)
}
x=c(3,4,0,1)
y=c(1,1,1,1)
hamming.distance(x,y)
x="Ciao"
y="Ciad"
hamming.distance(x,y)
x="Ciao"
length(x)
)
nchar(x)
x=c(3,4,0,1)
x=as.string(x)
#Come implementare la distanza di Hamming con R?
#Esiste una funzione Hamming Distance ma funziona in modo booleano
#Quindi se due elementi sono zero (o entrambi diversi da 0) mi da true
#Altrimenti se uno è 0 e l'altro no mi da false
#Io voglio implementare una funzione che confronti i singoli elementi
hamming.distance<-function (x, y)
{
x=paste(x,collapse="")
y=paste(y,collapse="")
if(nchar(x)!=nchar(y))
{
stop("x and y must have the same length")
}
l=nchar(x)
z <- apply(do.call(rbind, strsplit(c(x, y), "")), 2,
function(x){length(unique(x[!x %in% "_"])) == 1})
z=l-sum(z)
return(z)
}
x=c(3,4,0,1)
y=c(1,1,1,1)
hamming.distance(x,y)
x="Ciao"
y="Ciad"
hamming.distance(x,y)
?strcmp
x
y
setdiff(x,y)
adist(x,y)
x="CiaoCiao"
y="ZiaoZiao"
adist(x,y)
#Come implementare la distanza di Hamming con R?
#Esiste una funzione Hamming Distance ma funziona in modo booleano
#Quindi se due elementi sono zero (o entrambi diversi da 0) mi da true
#Altrimenti se uno è 0 e l'altro no mi da false
#Io voglio implementare una funzione che confronti i singoli elementi
hamming.distance<-function (x, y)
{
x=paste(x,collapse="")
y=paste(y,collapse="")
if(nchar(x)!=nchar(y))
{
stop("x and y must have the same length")
}
z <- adist(x,y)
return(z)
}
x=c(3,4,0,1)
y=c(1,1,1,1)
hamming.distance(x,y)
x="Ciao"
y="Ciad"
hamming.distance(x,y)
z
adist(x,y)
a <- adist(x,y)
a
a[1,1]
str(a)
str(a[1,1])
#Come implementare la distanza di Hamming con R?
#Esiste una funzione Hamming Distance ma funziona in modo booleano
#Quindi se due elementi sono zero (o entrambi diversi da 0) mi da true
#Altrimenti se uno è 0 e l'altro no mi da false
#Io voglio implementare una funzione che confronti i singoli elementi
hamming.distance<-function (x, y)
{
x=paste(x,collapse="")
y=paste(y,collapse="")
if(nchar(x)!=nchar(y))
{
stop("x and y must have the same length")
}
z <- adist(x,y)[1,1]
return(z)
}
x=c(3,4,0,1)
y=c(1,1,1,1)
hamming.distance(x,y)
x="Ciao"
y="Ciad"
hamming.distance(x,y)
?adist
adist("Ciao","Cia")
adist("Ciao","Ci")
#Come implementare la distanza di Hamming con R?
#Esiste una funzione Hamming Distance ma funziona in modo booleano
#Quindi se due elementi sono zero (o entrambi diversi da 0) mi da true
#Altrimenti se uno è 0 e l'altro no mi da false
#Io voglio implementare una funzione che confronti i singoli elementi
hamming.distance<-function (x, y)
{
x=paste(x,collapse="")
y=paste(y,collapse="")
if(nchar(x)!=nchar(y))
{
stop("x and y must have the same length")
}
z <- adist(x,y) #Misura la distanza tra stringhe
return(z)
}
x=c(3,4,0,1)
y=c(1,1,1,1)
hamming.distance(x,y)
x="Ciao"
y="Ciad"
hamming.distance(x,y)
#Come implementare la distanza di Hamming con R?
#Esiste una funzione Hamming Distance ma funziona in modo booleano
#Quindi se due elementi sono zero (o entrambi diversi da 0) mi da true
#Altrimenti se uno è 0 e l'altro no mi da false
#Io voglio implementare una funzione che confronti i singoli elementi
hamming.distance<-function (x, y)
{
x=paste(x,collapse="")
y=paste(y,collapse="")
if(nchar(x)!=nchar(y))
{
stop("x and y must have the same length")
}
z <- adist(x,y)[1,1] #Misura la distanza tra stringhe
return(z)
}
x=c(3,4,0,1)
y=c(1,1,1,1)
hamming.distance(x,y)
x="Ciao"
y="Ciad"
hamming.distance(x,y)
x=c("C","i","a","o")
y=c("C","i","a","d")
hamming.distance(x,y)
x="Coai"
y="Ciao"
hamming.distance(x,y)
y="Cioa"
hamming.distance(x,y)
x
y
hamming.distance(x,y)
x="aaab"
y="baaa"
hamming.distance(x,y)
y="aaac"
hamming.distance(x,y)
y="aaba"
hamming.distance(x,y)
x="ciao"
y="oaic"
hamming.distance(x,y)
x="Ciao"
y="Coia"
hamming.distance(x,y)
x="1234"
y="1111"
hamming.distance(x,y)
y="1234"
hamming.distance(x,y)
y="4321"
hamming.distance(x,y)
y="4231"
hamming.distance(x,y)
x="Ciao"
y="Coia"
hamming.distance(x,y)
y="coia"
hamming.distance(x,y)
x="ciao"
hamming.distance(x,y)
y="Ciao"
x="Coia"
hamming.distance(x,y) #perché viene 2? Dovrebbe essere 3
#Come implementare la distanza di Hamming con R?
#Esiste una funzione
hamming.distance<-function (x, y)
{
if(length(x)!=length(y))
{
stop("x and y must have the same length")
}
x=paste(x,collapse="")
y=paste(y,collapse="")
z <- apply(do.call(rbind, strsplit(c(x, y), "")), 2,
function(x){length(unique(x[!x %in% "_"])) == 1})
z=sum(z)
}
y="Ciao"
x="Coia"
hamming.distance(x,y) #perché viene 2? Dovrebbe essere 3
#Come implementare la distanza di Hamming con R?
#Esiste una funzione Hamming Distance ma funziona in modo booleano
#Quindi se due elementi sono zero (o entrambi diversi da 0) mi da true
#Altrimenti se uno è 0 e l'altro no mi da false
#Io voglio implementare una funzione che confronti i singoli elementi
hamming.distance<-function (x, y)
{
x=paste(x,collapse="")
y=paste(y,collapse="")
if(nchar(x)!=nchar(y))
{
stop("x and y must have the same length")
}
l=nchar(x)
z <- apply(do.call(rbind, strsplit(c(x, y), "")), 2,
function(x){length(unique(x[!x %in% "_"])) == 1})
z=l-sum(z)
return(z)
}
y="Ciao"
x="Coia"
hamming.distance(x,y) #perché viene 2? Dovrebbe essere 3
#Sembra funzionare, tranne in quel caso. Una versione meno "smart" invece sembra funzionare sempre
hamming.distance<-function (x, y)
{
x=paste(x,collapse="")
y=paste(y,collapse="")
if(nchar(x)!=nchar(y))
{
stop("x and y must have the same length")
}
l=nchar(x)
z <- apply(do.call(rbind, strsplit(c(x, y), "")), 2,
function(x){length(unique(x[!x %in% "_"])) == 1})
z=l-sum(z)
return(z)
}
x=c(3,4,0,1)
y=c(1,1,1,1)
hamming.distance(x,y)
x="Ciao"
y="Ciad"
hamming.distance(x,y)
x=c("C","i","a","o")
y=c("C","i","a","d")
hamming.distance(x,y)
y="Ciao"
x="Coia"
hamming.distance(x,y) #perché viene 2? Dovrebbe essere 3
nobs <- 10000
ndim <- 20
data <- matrix(runif(nobs*ndim), ncol=ndim)
library(BiocNeighbors)
fout <- findKNN(data, k=10, BNPARAM=KmknnParam())
head(fout$index)
#Esempio 1
#10 osservazioni 2 dimensioni
data1 <- matrix(c(1,1,10,10,1,2,20,20,2,1,20,30,30,30,300,100,200,100,0.3,0.3),ncol=2,byrow=T)
str(fout)
fout1 <- findKNN(data1, k=2, BNPARAM=KmknnParam("Hamming")) #k=2 2 vicini più vicini
fout1 <- findKNN(data1, k=2, BNPARAM=KmknnParam("brr")) #k=2 2 vicini più vicini
fout1 <- findKNN(data1, k=2, BNPARAM=KmknnParam()) #k=2 2 vicini più vicini
fout1 <- findKNN(data1, k=2, BNPARAM=KmknnParam("Euclidean")) #k=2 2 vicini più vicini
#Confronto data1 e query1
qout <- queryKNN(data1, query1, k=2, BNPARAM=KmknnParam(distance="Euclidean")) #distance può essere manhattan o euclidean
a=matrix(c(2,100,0,1),2,2)
a
colsums(a)
colSums(a)
library(devtools)
load_all()
.Last.error
library(devtools)
load_all()
library(devtools)
load_all()
data=matrix(c(1,1,2,2,100,100),3,2,byrow=T)
fout2 <- findKNN(data,k=1,BNPARAM=VptreeParam(distance="Hamming"))
fout2
data
data=matrix(c(1,1,2,2,100,100,101,101),4,2,byrow=T)
fout2 <- findKNN(data,k=1,BNPARAM=VptreeParam(distance="Hamming"))
fout2
data
data=matrix(c(1,1,2,2,1,1,3,3),4,2,byrow=T)
fout2 <- findKNN(data,k=1,BNPARAM=VptreeParam(distance="Hamming"))
fout2
data=matrix(c(1,1,2,2,1,1,3,3,1,1,1,1),3,4,byrow=T)
fout2 <- findKNN(data,k=1,BNPARAM=VptreeParam(distance="Hamming"))
fout2
library(devtools)
load_all()
data=matrix(c(1,1,2,2,1,1,3,3,1,1,1,1),3,4,byrow=T)
fout2 <- findKNN(data,k=1,BNPARAM=VptreeParam(distance="Hamming"))
fout2
data=matrix(c(1,1,2,2,1,1,3,3,1,1,1,1),3,4,byrow=T)
fout2 <- findKNN(data,k=1,BNPARAM=VptreeParam(distance="Hamming"))
fout2
data
load_all()
data=matrix(c(1,1,2,2,1,1,3,3,1,1,1,1),3,4,byrow=T)
fout2 <- findKNN(data,k=1,BNPARAM=VptreeParam(distance="Hamming"))
fout2
load_all()
data=matrix(c(1,1,2,2,1,1,3,3,1,1,1,1),3,4,byrow=T)
fout2 <- findKNN(data,k=1,BNPARAM=VptreeParam(distance="Hamming"))
fout2
data
load_all()
data=matrix(c(1,1,2,2,1,1,3,3,1,1,1,1),3,4,byrow=T)
fout2 <- findKNN(data,k=1,BNPARAM=VptreeParam(distance="Hamming"))
fout2
data
data=matrix(c(1,1,1,2,1,1,3,3,1,1,1,1),3,4,byrow=T)
fout2 <- findKNN(data,k=1,BNPARAM=VptreeParam(distance="Hamming"))
fout2
data
load_all()
data=matrix(c(1,1,1,2,1,1,3,3,1,1,1,1),3,4,byrow=T)
fout2 <- findKNN(data,k=1,BNPARAM=VptreeParam(distance="Hamming"))
fout2
data
data
data=matrix(c(1,1,1,1,1,3,1,1,1),3,3,byrow=T)
fout2 <- findKNN(data,k=1,BNPARAM=VptreeParam(distance="Hamming"))
fout2
data
load_all()
data=matrix(c(1,1,1,1,1,3,1,1,1),3,3,byrow=T)
fout2 <- findKNN(data,k=1,BNPARAM=VptreeParam(distance="Hamming"))
fout2
data
library(devtools)
load_all()
data=matrix(c(1,1,1,1,1,3,1,1,1),3,3,byrow=T)
fout2 <- findKNN(data,k=1,BNPARAM=VptreeParam(distance="Hamming"))
fout2
data
load_all()
data=matrix(c(1,1,1,1,1,3,2,2,1),3,3,byrow=T)
fout2 <- findKNN(data,k=1,BNPARAM=VptreeParam(distance="Hamming"))
fout2
data
data=matrix(c(1,1,1,1,1,1,3,1,2,2,2,2),4,3,byrow=T)
fout2 <- findKNN(data,k=1,BNPARAM=VptreeParam(distance="Hamming"))
fout2
data
data=matrix(c(1,1,1,1,1,1,3,1,2,2,2,2),3,4,byrow=T)
fout2 <- findKNN(data,k=1,BNPARAM=VptreeParam(distance="Hamming"))
fout2
data
library(devtools)
load_all()
data=matrix(c(1,1,1,1,1,1,3,1,2,2,2,2),3,4,byrow=T)
fout2 <- findKNN(data,k=1,BNPARAM=VptreeParam(distance="Hamming"))
fout2
data
data=matrix(c(1,1,1,
1,1,2,
3,1,2,
2,2,2,
1,1,1),5,3,byrow=T)
fout2 <- findKNN(data,k=1,BNPARAM=VptreeParam(distance="Hamming"))
fout2
data
library(devtools)
load_all()
.Last.error
library(devtools)
load_all()
setwd("C:/Users/user1/Desktop/UNIVERSITA'/DATI AZIENDALI/googleplaystore")
setwd("C:/Users/user1/Desktop/UNIVERSITA'/DATI AZIENDALI/googleplaystore")
setwd("C:/Users/user1/Desktop/UNIVERSITA'/DATI AZIENDALI/googleplaystore")
ls()
rm(list=ls())
setwd("C:/Users/user1/Desktop/UNIVERSITA'/DATI AZIENDALI/googleplaystore")
read.csv("googleplaystore.csv")
gps=read.csv("googleplaystore.csv")
head(gps)
View(gps)
str(gps)
hist(rating)
hist(gps$rating)
hist(gps$Rating)
hist(gps$Rating,xlim=c(0,5))
hist(gps$Rating,xlim=c(0,5),nclass=100)
mean(gps$Rating)
gpsr=read.csv("googleplaystorereviws.csv")
gpsr=read.csv("googleplaystore_user_reviws.csv")
gpsr=read.csv("googleplaystore_user_reviews.csv")
head(gps)
View(gpsr)
library(devtools)
load_all()
library(devtools)
data=matrix(c(1,1,1,
1,1,2,
3,1,2,
2,2,2,
1,1,1),5,3,byrow=T)
fout2 <- findKNN(data,k=1,BNPARAM=VptreeParam(distance="Hamming"))
fout2
data
library(devtools)
load_all()
data=matrix(c(1,1,1,
1,1,2,
3,1,2,
2,2,2,
1,1,1),5,3,byrow=T)
data
fout2 <- findKNN(data,k=1,BNPARAM=VptreeParam(distance="Hamming"))
fout2
fout2 <- findKNN(data,k=2,BNPARAM=VptreeParam(distance="Hamming"))
fout2
